<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>mode-manager.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="BaseBrush.html">BaseBrush</a><ul class='methods'><li data-type='method'><a href="BaseBrush.html#bufferNeedsRecolor">bufferNeedsRecolor</a></li><li data-type='method'><a href="BaseBrush.html#colorPoint">colorPoint</a></li><li data-type='method'><a href="BaseBrush.html#deserialize">deserialize</a></li><li data-type='method'><a href="BaseBrush.html#nodeSelectionStrategy">nodeSelectionStrategy</a></li><li data-type='method'><a href="BaseBrush.html#prepare">prepare</a></li><li data-type='method'><a href="BaseBrush.html#rampConfiguration">rampConfiguration</a></li><li data-type='method'><a href="BaseBrush.html#requiredSchemaFields">requiredSchemaFields</a></li><li data-type='method'><a href="BaseBrush.html#serialize">serialize</a></li><li data-type='method'><a href="BaseBrush.html#stagingAttributes">stagingAttributes</a></li><li data-type='method'><a href="BaseBrush.html#unprepare">unprepare</a></li></ul></li><li><a href="BaseLoader.html">BaseLoader</a></li><li><a href="Box.html">Box</a><ul class='methods'><li data-type='method'><a href="Box.html#.fromBounds">fromBounds</a></li><li data-type='method'><a href="Box.html#bounds">bounds</a></li><li data-type='method'><a href="Box.html#intersects">intersects</a></li><li data-type='method'><a href="Box.html#subdivide">subdivide</a></li></ul></li><li><a href="BrushFactory.html">BrushFactory</a><ul class='methods'><li data-type='method'><a href="BrushFactory.html#.availableBrushes">availableBrushes</a></li><li data-type='method'><a href="BrushFactory.html#.createBrush">createBrush</a></li><li data-type='method'><a href="BrushFactory.html#.deregisterBrush">deregisterBrush</a></li><li data-type='method'><a href="BrushFactory.html#.deserializeBrushes">deserializeBrushes</a></li><li data-type='method'><a href="BrushFactory.html#.registerBrush">registerBrush</a></li><li data-type='method'><a href="BrushFactory.html#.serializeBrushes">serializeBrushes</a></li></ul></li><li><a href="BufferDownloadPipeline.html">BufferDownloadPipeline</a><ul class='methods'><li data-type='method'><a href="BufferDownloadPipeline.html#queue">queue</a></li></ul></li><li><a href="Device.html">Device</a><ul class='methods'><li data-type='method'><a href="Device.html#.caps">caps</a></li><li data-type='method'><a href="Device.html#.deviceSupportsPlasio">deviceSupportsPlasio</a></li><li data-type='method'><a href="Device.html#.overrideProperty">overrideProperty</a></li></ul></li><li><a href="Frustum.html">Frustum</a><ul class='methods'><li data-type='method'><a href="Frustum.html#update">update</a></li></ul></li><li><a href="FrustumLODNodePolicy.html">FrustumLODNodePolicy</a><ul class='methods'><li data-type='method'><a href="FrustumLODNodePolicy.html#hookedReload">hookedReload</a></li><li data-type='method'><a href="FrustumLODNodePolicy.html#start">start</a></li><li data-type='method'><a href="FrustumLODNodePolicy.html#stop">stop</a></li></ul></li><li><a href="GeoTransform.html">GeoTransform</a><ul class='methods'><li data-type='method'><a href="GeoTransform.html#coordinateSpaceBounds">coordinateSpaceBounds</a></li><li data-type='method'><a href="GeoTransform.html#coordinateSpaceCenter">coordinateSpaceCenter</a></li><li data-type='method'><a href="GeoTransform.html#coordinateSpaceRange">coordinateSpaceRange</a></li><li data-type='method'><a href="GeoTransform.html#transform">transform</a></li></ul></li><li><a href="GreyhoundPipelineLoader.html">GreyhoundPipelineLoader</a><ul class='methods'><li data-type='method'><a href="GreyhoundPipelineLoader.html#.load">load</a></li><li data-type='method'><a href="GreyhoundPipelineLoader.html#loadHierarchyInfo">loadHierarchyInfo</a></li><li data-type='method'><a href="GreyhoundPipelineLoader.html#queryFor">queryFor</a></li><li data-type='method'><a href="GreyhoundPipelineLoader.html#setColorChannelBrush">setColorChannelBrush</a></li><li data-type='method'><a href="GreyhoundPipelineLoader.html#setFilter">setFilter</a></li></ul></li><li><a href="LocalColorLoader.html">LocalColorLoader</a><ul class='methods'><li data-type='method'><a href="LocalColorLoader.html#additionalSchemaItems">additionalSchemaItems</a></li><li data-type='method'><a href="LocalColorLoader.html#channelColorRamp">channelColorRamp</a></li><li data-type='method'><a href="LocalColorLoader.html#colorPoint">colorPoint</a></li><li data-type='method'><a href="LocalColorLoader.html#needPropagation">needPropagation</a></li><li data-type='method'><a href="LocalColorLoader.html#prep">prep</a></li><li data-type='method'><a href="LocalColorLoader.html#propagationParamsFromLastPrep">propagationParamsFromLastPrep</a></li><li data-type='method'><a href="LocalColorLoader.html#queryFor">queryFor</a></li></ul></li><li><a href="ModeManager.html">ModeManager</a></li><li><a href="module-point-buffer-cache.PointBufferCache.html">PointBufferCache</a></li><li><a href="module-point-buffer-cache-PointBufferCache.PointBufferCache.html">PointBufferCache</a></li><li><a href="PointCloudViewer.html">PointCloudViewer</a><ul class='methods'><li data-type='method'><a href="PointCloudViewer.html#.canRunPlasio">canRunPlasio</a></li><li data-type='method'><a href="PointCloudViewer.html#getGeoTransform">getGeoTransform</a></li><li data-type='method'><a href="PointCloudViewer.html#getModeManager">getModeManager</a></li><li data-type='method'><a href="PointCloudViewer.html#getRenderer">getRenderer</a></li><li data-type='method'><a href="PointCloudViewer.html#setColorChannelBrushes">setColorChannelBrushes</a></li><li data-type='method'><a href="PointCloudViewer.html#setFilter">setFilter</a></li><li data-type='method'><a href="PointCloudViewer.html#start">start</a></li></ul></li><li><a href="TileLoader.html">TileLoader</a><ul class='methods'><li data-type='method'><a href="TileLoader.html#.loadImage">loadImage</a></li></ul></li><li><a href="TreeInfoCache.html">TreeInfoCache</a><ul class='methods'><li data-type='method'><a href="TreeInfoCache.html#nodeInfo">nodeInfo</a></li></ul></li><li><a href="TreeWalker.html">TreeWalker</a><ul class='methods'><li data-type='method'><a href="TreeWalker.html#clearAllNodes">clearAllNodes</a></li><li data-type='method'><a href="TreeWalker.html#walk">walk</a></li></ul></li></ul><h3>Modules</h3><ul><li><a href="module-point-buffer-cache.html">point-buffer-cache</a></li></ul><h3>Global</h3><ul><li><a href="global.html#accumulateStats">accumulateStats</a></li><li><a href="global.html#ClampSelector">ClampSelector</a></li><li><a href="global.html#compressColor">compressColor</a></li><li><a href="global.html#DEFAULT_TILE_SIZE">DEFAULT_TILE_SIZE</a></li><li><a href="global.html#enclosesBounds">enclosesBounds</a></li><li><a href="global.html#equalBounds">equalBounds</a></li><li><a href="global.html#hue2rgb">hue2rgb</a></li><li><a href="global.html#minmax">minmax</a></li><li><a href="global.html#NodeSelectionStrategy">NodeSelectionStrategy</a></li><li><a href="global.html#Parseabrush'sstringrepresentationintoausabledatastructure.">Parse a brush's string representation into a usable data structure.</a></li><li><a href="global.html#pickOne">pickOne</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">mode-manager.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>// mode-manager.js
// Based on what the user is doing in the scene, this class manages
// which modes are active and which ones aren't.  Provides hooks which
// can then be called through user menus etc.
//

import { getxy, getxyScreen, pickUIPoint } from "./util";
import { OrbitalCamera } from "./cameras/orbital";
import { PointPicker } from "./modes/point-picker";
import { LinePicker } from "./modes/line-picker";

/**
 * The mode manager class which manages several modes our UI interaction could be in.
 */
export class ModeManager {
    constructor(element, renderer, geoTransform,
                appConfig, viewChangedFn, defaultCameraParams) {
        this.e = element;
        this.r = renderer;
        this.geoTransform = geoTransform;
        this.appc = appConfig;

        this.currentMode = null; // what mode we're in right now?
        this.dragging = false;   // are we dragging?
        this.active = null;      // which mode was active when the dragging was initiated
        this.lastHoveredEntity = null; // needed to generate mouse-enter and mouse-leave events
        this.lockedMode = null;
        this.actionListeners = [];

        // browser clicks are weird a little bit, even if you move our mouse great distances
        // it sends out a click, we want a synthetic click event which is only raised when
        // a the mouse isn't moved too much or the delay between clicks isn't too much
        //
        this.synthClickEventInfo = {};

        // Our camera, fallback for most actions
        this.camera = new OrbitalCamera(element, renderer,
            this.geoTransform, viewChangedFn, defaultCameraParams);

        // camera mode is the default current mode
        this.currentMode = this.camera;

        // All the entity modes we handle for now
        this.entityManagers = {
            "point": new PointPicker(this, element, renderer),
            "line": new LinePicker(this, element, renderer)
        };

        let entityToManager = entity => {
            if (entity)
                return this.entityManagers[entity.type];
        };

        this.mouseMoveHandler = e => {
            e.preventDefault();

            let localSpace = getxy(e);
            let screenSpace = getxyScreen(e);

            if (this.lockedMode) {
                // when a mode lock is in progress, then just emit standard
                // mouse moves
                //
                return this.lockedMode.invokeHandler("mouse-move", {
                    event: e,
                    pos: localSpace,
                    screenPos: screenSpace
                });
            }

            if (this.dragging) {
                // We are dragging so ignore all the default stuff and just update the
                // mode we're updating
                if (this.active) {
                    this.active.owner.invokeHandler("dragging", {
                        event: e,
                        entity: this.active.entity,
                        pos: localSpace,
                        screenPos: screenSpace
                    });
                }
            }
            else {
                let entity = pickUIPoint(renderer, localSpace);

                if (!this.isSameEntity(entity, this.lastHoveredEntity)) {
                    // the last hovered entity changed, do the eventing for mouse enter/leave
                    if (this.lastHoveredEntity) {
                        let manager = entityToManager(this.lastHoveredEntity);
                        if (manager) manager.invokeHandler("mouse-leave", {
                            event: e,
                            entity: this.lastHoveredEntity,
                            pos: localSpace,
                            screenPos: screenSpace
                        });
                    }
                    // Invoke the handler on the next hovered entity
                    this.lastHoveredEntity = entity;
                    if (this.lastHoveredEntity) {
                        let manager = entityToManager(this.lastHoveredEntity);
                        if (manager) manager.invokeHandler("mouse-enter", {
                            event: e,
                            entity: this.lastHoveredEntity,
                            pos: localSpace,
                            screenPos: screenSpace
                        });
                    }
                }
            }
        };

        this.mouseUpHandler = e => {
            // The mouse was released, just send down the event to our active entity
            let localSpace = getxy(e);
            let screenSpace = getxyScreen(e);
            if (this.lockedMode) {
                return this.lockedMode.invokeHandler("mouse-up", {
                    event: e,
                    pos: localSpace,
                    screenPos: screenSpace
                });
            }

            if(this.active) {
                this.active.owner.invokeHandler("mouse-up", {
                    event: e,
                    entity: this.active.entity
                });


                // do we need to dispatch synthetic event?
                if (this.synthClickEventInfo != null) {
                    let ts = this.synthClickEventInfo.ts,
                        loc = this.synthClickEventInfo.pos;

                    var dist = vec2.dist(loc, screenSpace),
                        delay = Date.now() - ts;

                    // After long and arduous user study spanning over
                    // long periods of time and costing thousands of dollars these
                    // thresholds were determined.
                    //
                    if (dist &lt; 5 &amp;&amp; delay &lt; 500) {
                        // we need to invoke synthetic click
                        //
                        this.active.owner.invokeHandler("synthetic-click", {
                            pos: localSpace,
                            screenPos: screenSpace
                        });
                    }

                    this.synthClickEventInfo = {};
                }
                    
                

                this.active = null;
            }

            this.dragging = false;

            // remove handlers
            document.removeEventListener("mousemove", this.mouseMoveHandler);
            document.removeEventListener("mouseup", this.mouseUpHandler);
        };

        this.mouseDownHandler = e => {
            // if we clicked on an entity, we need to trigger the action on that
            // particular mode
            e.preventDefault();

            let localSpace = getxy(e);
            let screenSpace = getxyScreen(e);

            // if there is a mode lock active, then just send raw event down to the
            // locked mode
            if (this.lockedMode) {
                return this.lockedMode.invokeHandler("mouse-down", {
                    event: e,
                    pos: localSpace,
                    screenPos: screenSpace
                });
            }

            let entity = pickUIPoint(renderer, localSpace);
            let entityManager = entityToManager(entity);

            // The mouse button could've come down on an entity, which means that the entity
            // would need to be notified that it was invoked because one of its components were
            // clicked on
            if (entityManager) {
                this.active = {
                    owner: entityManager,
                    entity: entity
                };

                // tell the owner that it was invoked because one of its entities were clicked on
                entityManager.invokeHandler("mouse-down-on-entity", {
                    event: e,
                    entity: entity,
                    pos: localSpace,
                    screenPos: screenSpace
                });
            }
            else {
                // Nothing was clicked, so pass down the control to the current mode
                this.active = { owner: this.currentMode };
                this.currentMode.invokeHandler("mouse-down", {
                    event: e,
                    pos: localSpace,
                    screenPos: screenSpace
                });

                // store any synthetic click event information
                this.synthClickEventInfo = {
                    pos: screenSpace,
                    ts: Date.now()
                };
            }

            // If the user engaged a lock in this mouse down handler, we'd never see the mouse up event
            // (since the locked mode will get it), this means that we cannot initiate dragging mode
            if (!this.lockedMode) {
                // no lock mode was engaged, so we'd drag as usual
                this.dragging = true;
            }

            // attach the handlers to the document so that scope is global
            document.addEventListener("mousemove", this.mouseMoveHandler, true);
            document.addEventListener("mouseup", this.mouseUpHandler, true);
        };

        let eventDispatcher = (eventName) => {
            // if the active entity doesn't have a handler for the given event, propagate it to
            // the current active mode
            return e => {
                e.preventDefault();

                let localSpace = getxy(e);
                let screenSpace = getxyScreen(e);
                let entity = pickUIPoint(renderer, localSpace);
                let entityManager = entityToManager(entity);

                if (this.lockedMode) {
                    return this.lockedMode.invokeHandler(eventName, {
                        event: e,
                        pos: localSpace,
                        screenPos: screenSpace
                    });
                }

                let hasHandler = false;

                if (entityManager) {
                    hasHandler = entityManager.hasHandler(eventName);
                }

                if (hasHandler) {
                    entityManager.invokeHandler(eventName, {
                        event: e,
                        entity: entity,
                        pos: localSpace,
                        screenPos: screenSpace
                    });
                }
                else {
                    this.currentMode.invokeHandler(eventName, {
                        event: e,
                        pos: localSpace,
                        screenPos: screenSpace
                    });
                }
            }
        };

        this.doubleClickHandler = eventDispatcher("double-click");
        this.clickHandler = eventDispatcher("click");
        this.mouseWheelHandler = eventDispatcher("mouse-wheel");

        this.contextMenuHandler = e => {
            // the context menu handler works slightly differently, if there's a handler
            // available, the handler can return a list of actions to perform on the particular
            // context, these actions are passed down to the user of ModeManager for appropriate
            // display/action
            e.preventDefault();

            let localSpace = getxy(e);
            let screenSpace = getxyScreen(e);
            let entity = pickUIPoint(renderer, localSpace);
            let entityManager = entityToManager(entity);

            if (this.lockedMode) {
                // no context menu actions when a lock is on
                return;
            }

            let actions = null;
            if (entityManager) {
                actions = entityManager.invokeHandler("context-menu-on-entity", {
                    event: e,
                    entity: entity,
                    pos: localSpace,
                    screenPos: screenSpace
                });
            }
            else {
                // see if our current mode wants to override it
                actions = this.currentMode.invokeHandler("context-menu", {
                    event: e,
                    pos: localSpace,
                    screenPos: screenSpace
                });
            }

            // even if there are no actions available, we want to make sure we notify
            // our action listeners that that user attempted to see the actions
            //
            if (this.actionListeners.length > 0) {
                let acts = actions || {};
                // the context menu returned some actions, propagate these to the owner

                this.actionListeners.forEach(f => {
                    f.call(this, acts, {
                        pos: localSpace,
                        screenPos: screenSpace
                    });
                });
            }
        };

        let e = element ? element : document;

        e.addEventListener("mousedown", this.mouseDownHandler);
        e.addEventListener("dblclick", this.doubleClickHandler);
        e.addEventListener("click", this.clickHandler);
        e.addEventListener("contextmenu", this.contextMenuHandler);
        e.addEventListener("mousewheel", this.mouseWheelHandler);
        e.addEventListener("DOMMouseScroll", this.mouseWheelHandler);
    }

    get activeCamera() {
        return this.camera;
    }

    get applicationConfig() {
        return this.appc;
    }

    set activeMode(newMode) {
        // set the active mode for the mode manager, setting new mode as null is the
        // same as setting it to camera.
        if (!newMode || newMode === "camera") {
            this.currentMode = this.camera;
        }
        else {
            let mode = this.entityManagers[newMode];
            if (!mode)
                throw new Error("Don't recognize the mode you're trying to set: " + newMode);

            this.currentMode = mode;
        }
    }

    addActionListener(f) {
        this.actionListeners.push(f);
    }

    isSameEntity(a, b) {
        // rules for equivalence:
        // 1. Both entities are null
        // 2. Both entities have the same entity type and their manager says they are equivalent
        //

        // some shortpaths, two entityes
        if (a === null &amp;&amp; b === null) {
            // both null
            return true;
        }
        else if ((a === null &amp;&amp; b !== null) ||
            (b === null &amp;&amp; a !== null)) {
            // one of them null
            return false;
        }
        else if (a.type === b.type) {
            // the types are the same, which means that we delegate the equivalence test to the manager
            let manager = this.entityManagers[a.type];
            if (!manager)
                return false; // no manager
            return manager.isSameEntity(a, b);
        }

        return false;
    }

    propagateDataRangeHint(rx, ry, rz) {
        // propagate to all our modes
        const hint = {
            rx: rx,
            ry: ry,
            rz: rz
        };

        const toInvoke = Object.values(this.entityManagers).concat([this.camera]);

        toInvoke.forEach(v => {
            v.invokeHandler("hint-data-range", hint);
        });
    }

    lockMode() {
        this.lockedMode = this.currentMode;

        console.log("mode manager lock is ON", this.lockedMode);
    }

    unlockMode() {
        console.log("mode manager lock is OFF", this.lockedMode);

        this.lockedMode = null;
    }
}
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Thu Mar 16 2017 14:20:22 GMT-0500 (CDT) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
