<html>
  <style>
    body {
        margin: 0px;
    }
    #stats {
        font-family: 'Consolas', 'Monaco', monospace;
        color: white;
        background-color: rgba(0, 0, 0, 0.5);
        padding: 2px;
        position: absolute;
        top: 5px;
        right: 5px;
    }
  </style>

<body>
    <div id="app" style="width:100%;height:600px;"></div>
    <div id="stats"></div>
    <script>
       var DECOMPRESS_WORKER_PATH="/workers/decompress.js"
    </script>

    <script src="renderer/target/dev/renderer.js"></script>
    <script src="lib/dist/plasio-lib.js"></script>

    <script>
        var SERVER = "devdata.greyhound.io";
        var RESOURCE = "sandy-ell";
        var IMAGERY_SOURCE = "local.elevation";

        var lines = [];


        var get = function(url, cb) {
            var r = new XMLHttpRequest();
            r.onload = function() {
                if (r.status === 200) {
                    return cb(JSON.parse(r.response));
                }

                throw new Error("HTTP/GET failed for: " + url);
            };

            r.open("get", url);
            r.send();
        };

        var enablePointPicker = null, disablePointPicker = null;

        var commonStartup = function(f) {
            var stats = {};

            var e = document.getElementById("app");
            var r = renderer.core.createRenderer(e);

            get("http://" + SERVER + "/resource/" + RESOURCE + "/info", function(obj) {
                var bbox = obj.bounds.slice(0);
                var schema = obj.schema;

                // determine and set splitting cutoffs
                var stopSplitLevel = Math.ceil(Math.log(obj.numPoints) / Math.log(4)) + 1;

                PlasioLib.FrustumLODNodePolicy.STOP_SPLIT_DEPTH = stopSplitLevel;
                PlasioLib.FrustumLODNodePolicy.HARD_STOP_DEPTH = stopSplitLevel * 2;

                // put bbox in correct space, y goes up.
                bbox = [bbox[0], bbox[2], bbox[1], bbox[3], bbox[5], bbox[4]];

                var loaders = {
                    point: new PlasioLib.Loaders.GreyhoundPipelineLoader(SERVER, RESOURCE, bbox, schema, IMAGERY_SOURCE),
                    transform: new PlasioLib.Loaders.TransformLoader()
                };

                var p = new PlasioLib.FrustumLODNodePolicy(loaders, r, bbox);

                for (var l in loaders) {
                    r.addLoader(loaders[l].constructor);
                }

                var handleResize = function () {
                    r.setRenderViewSize(window.innerWidth, window.innerHeight);
                };

                window.onresize = handleResize;
                handleResize();

                /*
                overlay = function () {
                    var c = document.createElement("canvas");
                    c.width = 512;
                    c.height = 512;
                    var ctx = c.getContext('2d');

                    ctx.strokeStyle = "#ff0000";

                    ctx.lineWidth = 5;
                    ctx.strokeRect(50, 50, 200, 200);

                    r.addOverlay("1234", [-40000, -20000, 40000, 20000], c);
                };

                roverlay = function () {
                    r.removeOverlay("1234");
                };
                 */

                var maxColorComponent = null;
                r.addStatsListener("red", "col-listener", function(o, n) {
                    if (maxColorComponent === null && n) {
                        var keys = Object.keys(n);
                        for (var i = 0 ; i < keys.length ; i ++) {
                            var v = parseInt(keys[i]);
                            if (v > 255) {
                                maxColorComponent = 1 << 16;
                                break;
                            }
                        }

                        if (maxColorComponent === null) {
                            maxColorComponent = 1 << 8;
                        }

                        r.setRenderOptions({
                            maxColorComponent: maxColorComponent
                        });
                    }
                });

                f({element: e, renderer: r, policy: p});
            });
        };

        var decomposeCamParameters = function() {
            var q = window.location.search;
            if (q.length === 0) return null;

            q = q.slice(1);
            var s = q.split("&").reduce(function(a, v) {
                var p = v.split("=");
                var k = p[0], v = JSON.parse(decodeURIComponent(p[1]));
                a[k] = v;
                return a;
            }, {});


            return s;
        };

        var ownerStartup = function() {
            var s = commonStartup(function(s) {


                var e = s.element;
                var r = s.renderer;
                var p = s.policy;


                // for playing in repl
                window.s = s;

                var camParams = decomposeCamParameters();

                console.log("Camera parameters:", camParams);

                var modeManager = new PlasioLib.ModeManager(e, r, function(eye, target) {
                    r.setEyeTargetPosition(eye, target);
                }, camParams)

                modeManager.addActionListener(function(actions) {
                    console.log("context menu actions:", actions);
                });

                s.camera = null;
                s.modeManager = modeManager;

                // do some history setup
                window.onpopstate = function (event) {
                    modeManager.activeCamera.deserialize(event.state);
                };

                r.setClearColor(0.4, 0, 0);
                r.setRenderOptions({
                    pointSize: 2,
                    rgb_f: 1.0,
                    overlay_f: 0.0,
                    maxColorComponent: 1 << 8
                });

                p.on("bbox", function (bbox) {
                    var x = bbox.maxs[0] - bbox.mins[0],
                            y = bbox.maxs[1] - bbox.mins[1],
                            z = bbox.maxs[2] - bbox.mins[2];

                    // reset the state of our camera
                    if (!camParams)
                        modeManager.propagateDataRangeHint(x, y, z);

                    // update our renderer to set far clip plane to pretty far
                    var farPlane = Math.sqrt(x * x + y * y) * 2;
                    r.updateCamera(0, {far: farPlane});

                });

                p.on("view-changed", function () {
                    var state = modeManager.activeCamera.serialize();

                    var kv = function (k, first) {
                        return (first ? "?" : "&") + encodeURIComponent(k) + "=" + encodeURIComponent(JSON.stringify(state[k]));
                    };

                    var s = kv('distance', true) + kv('elevation') + kv('azimuth') + kv('maxDistance') + kv('distance') + kv('target');

                    history.pushState(state, "Viewing stuffs", s);
                });

                p.start();


                var pointPicker = null;
                enablePointPicker = function() {
                    modeManager.activeMode = "point";
                };

                disablePointPicker = function() {
                    modeManager.activeMode = "camera";
                };
            });
        };

        ownerStartup();

        var settings = function() {
            return {
                zrange: [-2000, 3000],
                rampColorStart: [1, 0, 0],
                rampColorEnd: [0, 1, 0],
                rgb_f: 0.5,
                map_f: 0.5
            };
        };
    </script>

    <button style="position:absolute;top:10px;right:280px;z-index:10000"
            onclick="javascript:enablePointPicker();">Enable Point Picker</button>

    <button style="position:absolute;top:10px;right:150px;z-index:10000"
            onclick="javascript:disablePointPicker();">Disable Point Picker</button>


</body>
</html>
